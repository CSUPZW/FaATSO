<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Faatso: Ray Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Faatso
   </div>
   <div id="projectbrief">Fast marching Anisotropic Acoustic emission Tomography using Standard Optimisation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_ray-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ray Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The class <a class="el" href="class_ray.html" title="The class Ray corresponds to a seismic ray. ">Ray</a> corresponds to a seismic ray.  
 <a href="class_ray.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="raylib_8hpp_source.html">raylib.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2e3d2c29f2df4ab3da10da79d4acb852"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e3d2c29f2df4ab3da10da79d4acb852"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#a2e3d2c29f2df4ab3da10da79d4acb852">Ray</a> ()</td></tr>
<tr class="memdesc:a2e3d2c29f2df4ab3da10da79d4acb852"><td class="mdescLeft">&#160;</td><td class="mdescRight">default class constructor <br /></td></tr>
<tr class="separator:a2e3d2c29f2df4ab3da10da79d4acb852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0467e19b3cf83467dab708af0f8d5d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#ae0467e19b3cf83467dab708af0f8d5d6">trace</a> (<a class="el" href="class_grid.html">Grid</a> &amp;, const double &amp;, const double &amp;, const double &amp;)</td></tr>
<tr class="memdesc:ae0467e19b3cf83467dab708af0f8d5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to compute the ray path based on a <a class="el" href="class_grid.html" title="The class Grid corresponds to the set of nodes at which arrival time is to be computed, and contains the methods to do that. ">Grid</a>.  <a href="#ae0467e19b3cf83467dab708af0f8d5d6">More...</a><br /></td></tr>
<tr class="separator:ae0467e19b3cf83467dab708af0f8d5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e61537ef33667eff39eaf62da7d0f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59e61537ef33667eff39eaf62da7d0f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>export_ascii</b> (const char *)</td></tr>
<tr class="separator:a59e61537ef33667eff39eaf62da7d0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1133e78e15ac3cd0feb2bc67d1033b68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#a1133e78e15ac3cd0feb2bc67d1033b68">compute_interp_der</a> (int, <a class="el" href="class_data.html">Data</a> &amp;, <a class="el" href="class_data.html">Data</a> &amp;)</td></tr>
<tr class="memdesc:a1133e78e15ac3cd0feb2bc67d1033b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to extract the derivatives of the arrival time with respect to the (log(V)) or E at each node, on a coarser grid (by a factor n in all dimensions) than the one used to compute the ray initially. The values of log(V) and E on a fine grid are supposed to correspond to a trilinear interpolation of the values on the coarse grid.  <a href="#a1133e78e15ac3cd0feb2bc67d1033b68">More...</a><br /></td></tr>
<tr class="separator:a1133e78e15ac3cd0feb2bc67d1033b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bc210ab5c67d0268a10fb4cc15dc71"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#a56bc210ab5c67d0268a10fb4cc15dc71">compute_t</a> (const <a class="el" href="class_data.html">Data</a> &amp;, const <a class="el" href="class_data.html">Data</a> &amp;)</td></tr>
<tr class="memdesc:a56bc210ab5c67d0268a10fb4cc15dc71"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to compute a travel time along the ray, given a velocity and anisotropy models (given on the same grid as the one used to initialise the ray).  <a href="#a56bc210ab5c67d0268a10fb4cc15dc71">More...</a><br /></td></tr>
<tr class="separator:a56bc210ab5c67d0268a10fb4cc15dc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6a19d9cffac14fda35259562887930"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#afe6a19d9cffac14fda35259562887930">compute_t_and_interp_der</a> (const <a class="el" href="class_data.html">Data</a> &amp;, const <a class="el" href="class_data.html">Data</a> &amp;, int, <a class="el" href="class_data.html">Data</a> &amp;, <a class="el" href="class_data.html">Data</a> &amp;, double &amp;, double &amp;, double &amp;)</td></tr>
<tr class="memdesc:afe6a19d9cffac14fda35259562887930"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to compute a travel time along the ray, given a velocity and anisotropy models (given on the same grid as the one used to initialise the ray), as well as the derivatives of the arrival time with respect to lnV and E, computed on a coarser grid (n times less nodes in each directions).  <a href="#afe6a19d9cffac14fda35259562887930">More...</a><br /></td></tr>
<tr class="separator:afe6a19d9cffac14fda35259562887930"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad160cb47acacdb05e920ce0d88135d2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad160cb47acacdb05e920ce0d88135d2c"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#ad160cb47acacdb05e920ce0d88135d2c">x</a></td></tr>
<tr class="memdesc:ad160cb47acacdb05e920ce0d88135d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of <img class="formulaInl" alt="$x$" src="form_2.png"/> coordinates of ray path <br /></td></tr>
<tr class="separator:ad160cb47acacdb05e920ce0d88135d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045afd15989ea118e479c7c564783964"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a045afd15989ea118e479c7c564783964"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#a045afd15989ea118e479c7c564783964">y</a></td></tr>
<tr class="memdesc:a045afd15989ea118e479c7c564783964"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of <img class="formulaInl" alt="$y$" src="form_6.png"/> coordinates of ray path <br /></td></tr>
<tr class="separator:a045afd15989ea118e479c7c564783964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e702c94a758047b9092ab08eda855e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14e702c94a758047b9092ab08eda855e"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#a14e702c94a758047b9092ab08eda855e">z</a></td></tr>
<tr class="memdesc:a14e702c94a758047b9092ab08eda855e"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of <img class="formulaInl" alt="$z$" src="form_7.png"/> coordinates of ray path <br /></td></tr>
<tr class="separator:a14e702c94a758047b9092ab08eda855e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839eb936105ab5d984bb91bdfb4245ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a839eb936105ab5d984bb91bdfb4245ff"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#a839eb936105ab5d984bb91bdfb4245ff">ind</a></td></tr>
<tr class="memdesc:a839eb936105ab5d984bb91bdfb4245ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of indices of nearest neighbour nodes along the ray path <br /></td></tr>
<tr class="separator:a839eb936105ab5d984bb91bdfb4245ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84f0d4f37969ac7333a9253b4c5fc1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab84f0d4f37969ac7333a9253b4c5fc1b"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#ab84f0d4f37969ac7333a9253b4c5fc1b">tan_theta</a></td></tr>
<tr class="memdesc:ab84f0d4f37969ac7333a9253b4c5fc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">array storing the tangent of the phase angle along the ray path <br /></td></tr>
<tr class="separator:ab84f0d4f37969ac7333a9253b4c5fc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d096e9699fb46b41452c5fc7b4c52c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7d096e9699fb46b41452c5fc7b4c52c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#af7d096e9699fb46b41452c5fc7b4c52c">Nx</a></td></tr>
<tr class="memdesc:af7d096e9699fb46b41452c5fc7b4c52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nx dimension of the grid in which the ray is traced. <br /></td></tr>
<tr class="separator:af7d096e9699fb46b41452c5fc7b4c52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcf6898c9aef86a15a3876ecbce1dd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5dcf6898c9aef86a15a3876ecbce1dd4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#a5dcf6898c9aef86a15a3876ecbce1dd4">Ny</a></td></tr>
<tr class="memdesc:a5dcf6898c9aef86a15a3876ecbce1dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ny dimension of the grid in which the ray is traced. <br /></td></tr>
<tr class="separator:a5dcf6898c9aef86a15a3876ecbce1dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc9a88559e4bfe1259f4cf937cdec42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fc9a88559e4bfe1259f4cf937cdec42"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#a2fc9a88559e4bfe1259f4cf937cdec42">Nz</a></td></tr>
<tr class="memdesc:a2fc9a88559e4bfe1259f4cf937cdec42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nz dimension of the grid in which the ray is traced. <br /></td></tr>
<tr class="separator:a2fc9a88559e4bfe1259f4cf937cdec42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbc95b84d8fd1d7980a737503c36890"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fbc95b84d8fd1d7980a737503c36890"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#a5fbc95b84d8fd1d7980a737503c36890">h</a></td></tr>
<tr class="memdesc:a5fbc95b84d8fd1d7980a737503c36890"><td class="mdescLeft">&#160;</td><td class="mdescRight">grid spacing. <br /></td></tr>
<tr class="separator:a5fbc95b84d8fd1d7980a737503c36890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5789a2463c98202618a3200fe099131"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5789a2463c98202618a3200fe099131"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#ac5789a2463c98202618a3200fe099131">der_x0</a></td></tr>
<tr class="memdesc:ac5789a2463c98202618a3200fe099131"><td class="mdescLeft">&#160;</td><td class="mdescRight">derivative of arrival time with respect to x position of first ray point (i.e. target point) <br /></td></tr>
<tr class="separator:ac5789a2463c98202618a3200fe099131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1b3b30f65ad1870db6032fd8880bee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada1b3b30f65ad1870db6032fd8880bee"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#ada1b3b30f65ad1870db6032fd8880bee">der_y0</a></td></tr>
<tr class="memdesc:ada1b3b30f65ad1870db6032fd8880bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">derivative of arrival time with respect to y position of first ray point <br /></td></tr>
<tr class="separator:ada1b3b30f65ad1870db6032fd8880bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26dc5d46b9ab5b57a542a1c2767861c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac26dc5d46b9ab5b57a542a1c2767861c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#ac26dc5d46b9ab5b57a542a1c2767861c">der_z0</a></td></tr>
<tr class="memdesc:ac26dc5d46b9ab5b57a542a1c2767861c"><td class="mdescLeft">&#160;</td><td class="mdescRight">derivative of arrival time with respect to z position of first ray point <br /></td></tr>
<tr class="separator:ac26dc5d46b9ab5b57a542a1c2767861c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce9fa0820b71647b2f90b1ba01e21c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ce9fa0820b71647b2f90b1ba01e21c1"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#a4ce9fa0820b71647b2f90b1ba01e21c1">der_v</a></td></tr>
<tr class="memdesc:a4ce9fa0820b71647b2f90b1ba01e21c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of derivatives with respect to v=ln(V) (V being horizontal velocity) <br /></td></tr>
<tr class="separator:a4ce9fa0820b71647b2f90b1ba01e21c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46826c9e90b1b5296b9d854a1ab793ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46826c9e90b1b5296b9d854a1ab793ed"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ray.html#a46826c9e90b1b5296b9d854a1ab793ed">der_E</a></td></tr>
<tr class="memdesc:a46826c9e90b1b5296b9d854a1ab793ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of derivatives with respect to E <br /></td></tr>
<tr class="separator:a46826c9e90b1b5296b9d854a1ab793ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class <a class="el" href="class_ray.html" title="The class Ray corresponds to a seismic ray. ">Ray</a> corresponds to a seismic ray. </p>
<p>A ray is traced a posteriori based on a regular <a class="el" href="class_grid.html" title="The class Grid corresponds to the set of nodes at which arrival time is to be computed, and contains the methods to do that. ">Grid</a> with computed arrival times. The tracing starts from the receiver (given as argument to the method <a class="el" href="class_ray.html#ae0467e19b3cf83467dab708af0f8d5d6" title="method to compute the ray path based on a Grid. ">Ray::trace</a>), and progresses with steps equal to the grid spacing along the ray direction. In isotropic media, the ray direction at each piont is normal to the wavefront, i.e., along the gradient of the arrival time. In anisotropic media, the ray direction is NOT normal to the wavefront, and at each position the ray angle is found based on a conversion between the phase angle and the group angle. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1133e78e15ac3cd0feb2bc67d1033b68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ray::compute_interp_der </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_data.html">Data</a> &amp;&#160;</td>
          <td class="paramname"><em>ddv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_data.html">Data</a> &amp;&#160;</td>
          <td class="paramname"><em>ddE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method to extract the derivatives of the arrival time with respect to the (log(V)) or E at each node, on a coarser grid (by a factor n in all dimensions) than the one used to compute the ray initially. The values of log(V) and E on a fine grid are supposed to correspond to a trilinear interpolation of the values on the coarse grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the refinement factor. </td></tr>
    <tr><td class="paramname">ddv</td><td>a <a class="el" href="class_data.html" title="The class Data is used to load and save the binaries used for input/output in the fmm main code...">Data</a> structure which will contain the interpolated derivatives with respect to v=lnV. </td></tr>
    <tr><td class="paramname">ddE</td><td>a <a class="el" href="class_data.html" title="The class Data is used to load and save the binaries used for input/output in the fmm main code...">Data</a> structure which will contain the interpolated derivatives with respect to E. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56bc210ab5c67d0268a10fb4cc15dc71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Ray::compute_t </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_data.html">Data</a> &amp;&#160;</td>
          <td class="paramname"><em>tab_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_data.html">Data</a> &amp;&#160;</td>
          <td class="paramname"><em>tab_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method to compute a travel time along the ray, given a velocity and anisotropy models (given on the same grid as the one used to initialise the ray). </p>
<p>This essentially computes <img class="formulaInl" alt="$t = \int_{Ray} (1/V_{group})ds.$" src="form_8.png"/> This is useful to recompute arrival times in a new velocity model assuming the ray path is fixed (e.g., avoiding to recompute the whole times in a new grid). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab_v</td><td><a class="el" href="class_data.html" title="The class Data is used to load and save the binaries used for input/output in the fmm main code...">Data</a> structure containing the ln(V) data, </td></tr>
    <tr><td class="paramname">tab_E</td><td><a class="el" href="class_data.html" title="The class Data is used to load and save the binaries used for input/output in the fmm main code...">Data</a> structure containing the E data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the travel time. </dd></dl>

</div>
</div>
<a class="anchor" id="afe6a19d9cffac14fda35259562887930"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Ray::compute_t_and_interp_der </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_data.html">Data</a> &amp;&#160;</td>
          <td class="paramname"><em>tab_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_data.html">Data</a> &amp;&#160;</td>
          <td class="paramname"><em>tab_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_data.html">Data</a> &amp;&#160;</td>
          <td class="paramname"><em>ddv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_data.html">Data</a> &amp;&#160;</td>
          <td class="paramname"><em>ddE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ddx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ddy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ddz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method to compute a travel time along the ray, given a velocity and anisotropy models (given on the same grid as the one used to initialise the ray), as well as the derivatives of the arrival time with respect to lnV and E, computed on a coarser grid (n times less nodes in each directions). </p>
<p>This essentially computes <img class="formulaInl" alt="$t = \int_{Ray} (1/V_{group})ds.$" src="form_8.png"/> and <img class="formulaInl" alt="$dt/dv, dt/dE$" src="form_9.png"/>. This is useful to recompute arrival times and frechet kernels in a new velocity model assuming the ray path is fixed (e.g., avoiding to recompute the whole times in a new grid). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab_v</td><td><a class="el" href="class_data.html" title="The class Data is used to load and save the binaries used for input/output in the fmm main code...">Data</a> structure containing the ln(V) data, </td></tr>
    <tr><td class="paramname">tab_E</td><td><a class="el" href="class_data.html" title="The class Data is used to load and save the binaries used for input/output in the fmm main code...">Data</a> structure containing the E data. </td></tr>
    <tr><td class="paramname">n</td><td>the grid refinement factor. </td></tr>
    <tr><td class="paramname">ddv</td><td><a class="el" href="class_data.html" title="The class Data is used to load and save the binaries used for input/output in the fmm main code...">Data</a> structure to store the values of dt/dv (v on coraser grid). </td></tr>
    <tr><td class="paramname">ddE</td><td><a class="el" href="class_data.html" title="The class Data is used to load and save the binaries used for input/output in the fmm main code...">Data</a> structure to store the values of dt/dE (E on coarser grid). </td></tr>
    <tr><td class="paramname">ddx</td><td>the value (double) of dt/dx0. </td></tr>
    <tr><td class="paramname">ddy</td><td>the value (double) of dt/dy0. </td></tr>
    <tr><td class="paramname">ddz</td><td>the value (double) of dt/dz0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the travel time. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0467e19b3cf83467dab708af0f8d5d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ray::trace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>xr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>yr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>zr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method to compute the ray path based on a <a class="el" href="class_grid.html" title="The class Grid corresponds to the set of nodes at which arrival time is to be computed, and contains the methods to do that. ">Grid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grd</td><td>the <a class="el" href="class_grid.html" title="The class Grid corresponds to the set of nodes at which arrival time is to be computed, and contains the methods to do that. ">Grid</a> in which arrival times T have been computed </td></tr>
    <tr><td class="paramname">xr</td><td><img class="formulaInl" alt="$x$" src="form_2.png"/> coordinate of receiver point </td></tr>
    <tr><td class="paramname">yr</td><td><img class="formulaInl" alt="$y$" src="form_6.png"/> coordinate of receiver point </td></tr>
    <tr><td class="paramname">zr</td><td><img class="formulaInl" alt="$z$" src="form_7.png"/> coordinate of receiver point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Volumes/Data/Projects/Tomography/Faatso/include/<a class="el" href="raylib_8hpp_source.html">raylib.hpp</a></li>
<li>/Volumes/Data/Projects/Tomography/Faatso/src/raylib.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
