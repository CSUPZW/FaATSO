<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Faatso: Grid Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Faatso
   </div>
   <div id="projectbrief">Fast marching Anisotropic Acoustic emission Tomography using Standard Optimisation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_grid-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Grid Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The class <a class="el" href="class_grid.html" title="The class Grid corresponds to the set of nodes at which arrival time is to be computed, and contains the methods to do that. ">Grid</a> corresponds to the set of nodes at which arrival time is to be computed, and contains the methods to do that.  
 <a href="class_grid.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="fmmlib_8hpp_source.html">fmmlib.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acecf610ba3dbc40e048d00d4585e755a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#acecf610ba3dbc40e048d00d4585e755a">Grid</a> (const int &amp;, const int &amp;, const int &amp;, const double &amp;)</td></tr>
<tr class="memdesc:acecf610ba3dbc40e048d00d4585e755a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor.  <a href="#acecf610ba3dbc40e048d00d4585e755a">More...</a><br /></td></tr>
<tr class="separator:acecf610ba3dbc40e048d00d4585e755a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3661d0a7f998caaaf8627d7a67072116"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3661d0a7f998caaaf8627d7a67072116"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a3661d0a7f998caaaf8627d7a67072116">~Grid</a> ()</td></tr>
<tr class="memdesc:a3661d0a7f998caaaf8627d7a67072116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class destructor. <br /></td></tr>
<tr class="separator:a3661d0a7f998caaaf8627d7a67072116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525c06212728b34d29fef58a3a6d27f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a525c06212728b34d29fef58a3a6d27f8">initialise</a> (const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;)</td></tr>
<tr class="memdesc:a525c06212728b34d29fef58a3a6d27f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to initialise grid.  <a href="#a525c06212728b34d29fef58a3a6d27f8">More...</a><br /></td></tr>
<tr class="separator:a525c06212728b34d29fef58a3a6d27f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457b4cc1c95623e35e6d16a855b6781e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a457b4cc1c95623e35e6d16a855b6781e">initialise_log</a> (const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;)</td></tr>
<tr class="memdesc:a457b4cc1c95623e35e6d16a855b6781e"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to initialise grid using a vecotr of logV instead of V.  <a href="#a457b4cc1c95623e35e6d16a855b6781e">More...</a><br /></td></tr>
<tr class="separator:a457b4cc1c95623e35e6d16a855b6781e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9b3a29c1b401552b312e9f26eda623"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac9b3a29c1b401552b312e9f26eda623"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#aac9b3a29c1b401552b312e9f26eda623">reset_T</a> ()</td></tr>
<tr class="memdesc:aac9b3a29c1b401552b312e9f26eda623"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to reset all nodes of the grid to +infinity, so that the grid is ready for another computation using the same V and E etc. <br /></td></tr>
<tr class="separator:aac9b3a29c1b401552b312e9f26eda623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7695627b9a8573fa614ade7d7720ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf7695627b9a8573fa614ade7d7720ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#acf7695627b9a8573fa614ade7d7720ef">reset</a> (const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;)</td></tr>
<tr class="memdesc:acf7695627b9a8573fa614ade7d7720ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to reset all nodes of the grid to +infinity, and changes the values of V and E at all nodes, so that the grid is ready for another computation using the new V and E. <br /></td></tr>
<tr class="separator:acf7695627b9a8573fa614ade7d7720ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ab376fb6fa2ef97b52b02e93619676"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a36ab376fb6fa2ef97b52b02e93619676">march</a> (const int &amp;, const bool &amp;)</td></tr>
<tr class="memdesc:a36ab376fb6fa2ef97b52b02e93619676"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to perform the fast marching method and compute arrival times at each node.  <a href="#a36ab376fb6fa2ef97b52b02e93619676">More...</a><br /></td></tr>
<tr class="separator:a36ab376fb6fa2ef97b52b02e93619676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e192bc08a5483b9f503fb1a46d7cd8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a67e192bc08a5483b9f503fb1a46d7cd8">export_Tvector</a> ()</td></tr>
<tr class="memdesc:a67e192bc08a5483b9f503fb1a46d7cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to export the arrival times into a <a class="el" href="class_data.html" title="The class Data is used to load and save the binaries used for input/output in the fmm main code...">Data</a> structure, to save it later.  <a href="#a67e192bc08a5483b9f503fb1a46d7cd8">More...</a><br /></td></tr>
<tr class="separator:a67e192bc08a5483b9f503fb1a46d7cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91177a96caba01154349f06348e1f680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a91177a96caba01154349f06348e1f680">import_T</a> (const <a class="el" href="class_data.html">Data</a> &amp;)</td></tr>
<tr class="memdesc:a91177a96caba01154349f06348e1f680"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to import arrival times from a <a class="el" href="class_data.html" title="The class Data is used to load and save the binaries used for input/output in the fmm main code...">Data</a> structure.  <a href="#a91177a96caba01154349f06348e1f680">More...</a><br /></td></tr>
<tr class="separator:a91177a96caba01154349f06348e1f680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b0fe20398c55fd1643e0fbea912ac7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a82b0fe20398c55fd1643e0fbea912ac7">sub2ind</a> (const int &amp;, const int &amp;, const int &amp;)</td></tr>
<tr class="memdesc:a82b0fe20398c55fd1643e0fbea912ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to convert subscript to linear indices.  <a href="#a82b0fe20398c55fd1643e0fbea912ac7">More...</a><br /></td></tr>
<tr class="separator:a82b0fe20398c55fd1643e0fbea912ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719cd86ef4cafeb3fe257c1c50bc63d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a719cd86ef4cafeb3fe257c1c50bc63d7">ind2sub</a> (const int &amp;, int &amp;, int &amp;, int &amp;)</td></tr>
<tr class="memdesc:a719cd86ef4cafeb3fe257c1c50bc63d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to convert linear to subscript indices:  <a href="#a719cd86ef4cafeb3fe257c1c50bc63d7">More...</a><br /></td></tr>
<tr class="separator:a719cd86ef4cafeb3fe257c1c50bc63d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a5096f486b265399bd0b8f111d015f51a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5096f486b265399bd0b8f111d015f51a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a5096f486b265399bd0b8f111d015f51a">Nx</a></td></tr>
<tr class="memdesc:a5096f486b265399bd0b8f111d015f51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of nodes in the x direction <br /></td></tr>
<tr class="separator:a5096f486b265399bd0b8f111d015f51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ce71c381de38a654c3395855a3ae5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99ce71c381de38a654c3395855a3ae5d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a99ce71c381de38a654c3395855a3ae5d">Ny</a></td></tr>
<tr class="memdesc:a99ce71c381de38a654c3395855a3ae5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of nodes in the y direction <br /></td></tr>
<tr class="separator:a99ce71c381de38a654c3395855a3ae5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0609b6070bad52fbb2a7c16c927246"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade0609b6070bad52fbb2a7c16c927246"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#ade0609b6070bad52fbb2a7c16c927246">Nz</a></td></tr>
<tr class="memdesc:ade0609b6070bad52fbb2a7c16c927246"><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of nodes in the z direction <br /></td></tr>
<tr class="separator:ade0609b6070bad52fbb2a7c16c927246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d59374f53543d1fbc59f42014b769aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d59374f53543d1fbc59f42014b769aa"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a6d59374f53543d1fbc59f42014b769aa">Ntot</a></td></tr>
<tr class="memdesc:a6d59374f53543d1fbc59f42014b769aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">the total number of nodes <br /></td></tr>
<tr class="separator:a6d59374f53543d1fbc59f42014b769aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41842316ab09c4808e1e22a1af763975"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41842316ab09c4808e1e22a1af763975"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a41842316ab09c4808e1e22a1af763975">h</a></td></tr>
<tr class="memdesc:a41842316ab09c4808e1e22a1af763975"><td class="mdescLeft">&#160;</td><td class="mdescRight">the node spacing <br /></td></tr>
<tr class="separator:a41842316ab09c4808e1e22a1af763975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7441f76ba57ccafa703e00f6d052d4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7441f76ba57ccafa703e00f6d052d4b"></a>
std::vector&lt; <a class="el" href="class_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#ae7441f76ba57ccafa703e00f6d052d4b">node</a></td></tr>
<tr class="memdesc:ae7441f76ba57ccafa703e00f6d052d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the vector of nodes <br /></td></tr>
<tr class="separator:ae7441f76ba57ccafa703e00f6d052d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34f392a5478915fc4450302917ed06e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af34f392a5478915fc4450302917ed06e"></a>
std::vector&lt; handle_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#af34f392a5478915fc4450302917ed06e">tab_handle_trial</a></td></tr>
<tr class="memdesc:af34f392a5478915fc4450302917ed06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of handles in the trial heap <br /></td></tr>
<tr class="separator:af34f392a5478915fc4450302917ed06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7f84c052ee92ba4c80f89b4ecd602f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f7f84c052ee92ba4c80f89b4ecd602f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a9f7f84c052ee92ba4c80f89b4ecd602f">ind_source</a></td></tr>
<tr class="memdesc:a9f7f84c052ee92ba4c80f89b4ecd602f"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear index of source node <br /></td></tr>
<tr class="separator:a9f7f84c052ee92ba4c80f89b4ecd602f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class <a class="el" href="class_grid.html" title="The class Grid corresponds to the set of nodes at which arrival time is to be computed, and contains the methods to do that. ">Grid</a> corresponds to the set of nodes at which arrival time is to be computed, and contains the methods to do that. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acecf610ba3dbc40e048d00d4585e755a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Grid::Grid </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>hh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nx</td><td>the number of nodes in x direction (Nx) </td></tr>
    <tr><td class="paramname">ny</td><td>the number of nodes in y direction (Ny) </td></tr>
    <tr><td class="paramname">nz</td><td>the number of nodes in z direction (Nz) </td></tr>
    <tr><td class="paramname">hh</td><td>the grid spacing (h) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a67e192bc08a5483b9f503fb1a46d7cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Grid::export_Tvector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method to export the arrival times into a <a class="el" href="class_data.html" title="The class Data is used to load and save the binaries used for input/output in the fmm main code...">Data</a> structure, to save it later. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of &lt;double&gt; containing T of all nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="a91177a96caba01154349f06348e1f680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::import_T </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_data.html">Data</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method to import arrival times from a <a class="el" href="class_data.html" title="The class Data is used to load and save the binaries used for input/output in the fmm main code...">Data</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a <a class="el" href="class_data.html" title="The class Data is used to load and save the binaries used for input/output in the fmm main code...">Data</a> object (loaded with arrival times). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a719cd86ef4cafeb3fe257c1c50bc63d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::ind2sub </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method to convert linear to subscript indices: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ind</td><td>the linear index to be computed </td></tr>
    <tr><td class="paramname">i</td><td>subcript index (i-th node in x direction in the grid) </td></tr>
    <tr><td class="paramname">j</td><td>subcript index (j-th node in y direction in the grid) </td></tr>
    <tr><td class="paramname">k</td><td>subcript index (k-th node in z direction in the grid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a525c06212728b34d29fef58a3a6d27f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::initialise </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method to initialise grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vel</td><td>a vector of size Ntot which contains the horizontal wavespeed at each node. </td></tr>
    <tr><td class="paramname">eps</td><td>a vector of size Ntot which contains the anisotropy parameter at each node. Note that no check is made that vel and eps are indeed of size Ntot. The code will crash is they aren't. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a457b4cc1c95623e35e6d16a855b6781e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::initialise_log </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>lvel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method to initialise grid using a vecotr of logV instead of V. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lvel</td><td>a vector of size Ntot which contains the log horizontal wavespeed at each node. </td></tr>
    <tr><td class="paramname">eps</td><td>a vector of size Ntot which contains the anisotropy parameter at each node. Note that no check is made that vel and eps are indeed of size Ntot. The code will crash is they aren't. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36ab376fb6fa2ef97b52b02e93619676"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Grid::march </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>ind0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method to perform the fast marching method and compute arrival times at each node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ind0</td><td>index of the source node, which has an arrival time of 0.0 </td></tr>
    <tr><td class="paramname">box</td><td>true if a sourcebox with analytical solutions is to be used, false otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of iterations. </dd></dl>

</div>
</div>
<a class="anchor" id="a82b0fe20398c55fd1643e0fbea912ac7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Grid::sub2ind </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method to convert subscript to linear indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>subcript index (i-th node in x direction in the grid) </td></tr>
    <tr><td class="paramname">j</td><td>subcript index (j-th node in y direction in the grid) </td></tr>
    <tr><td class="paramname">k</td><td>subcript index (k-th node in z direction in the grid) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the linear index of the node in the grid. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Volumes/Data/Projects/Tomography/Faatso/include/<a class="el" href="fmmlib_8hpp_source.html">fmmlib.hpp</a></li>
<li>/Volumes/Data/Projects/Tomography/Faatso/src/fmmlib.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
